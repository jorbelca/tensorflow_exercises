<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@2.7.0/dist/tf.min.js"></script>
    <title>Capstone Project</title>
  </head>
  <body>
    <canvas id="canvas1" width="120" height="120"></canvas>
  </body>

  <script>
    // Coordenadas de los pips para cada cara
    const dicePatterns = {
      1: [[6, 6]],
      2: [
        [3, 3],
        [9, 9],
      ],
      3: [
        [3, 3],
        [6, 6],
        [9, 9],
      ],
      4: [
        [3, 3],
        [3, 9],
        [9, 3],
        [9, 9],
      ],
      5: [
        [3, 3],
        [3, 9],
        [9, 3],
        [9, 9],
        [6, 6],
      ],
      6: [
        [3, 3],
        [3, 6],
        [3, 9],
        [9, 3],
        [9, 6],
        [9, 9],
      ],
      7: [
        [3, 3],
        [3, 9],
        [9, 3],
        [9, 9],
        [6, 6],
        [3, 6],
        [9, 6],
      ],
      8: [
        [3, 3],
        [3, 9],
        [9, 3],
        [9, 9],
        [6, 6],
        [6, 3],
        [6, 9],
        [9, 6],
      ],
      9: [
        [3, 3],
        [3, 9],
        [9, 3],
        [9, 9],
        [6, 6],
        [6, 3],
        [6, 9],
        [3, 6],
        [9, 6],
      ],
    };

    function createDie(face) {
      // empezamos con todo blanco
      let arr = Array(12)
        .fill()
        .map(() => Array(12).fill(1.0));

      // pintamos los pips
      dicePatterns[face].forEach(([x, y]) => {
        for (let i = x - 1; i <= x + 1; i++) {
          for (let j = y - 1; j <= y + 1; j++) {
            if (i >= 0 && i < 12 && j >= 0 && j < 12) {
              arr[i][j] = 0.0;
            }
          }
        }
      });

      return tf.tensor2d(arr);
    }
    function addNoise(tensor, noiseLevel = 0.1) {
      return tf.tidy(() => {
        const noise = tf.randomUniform(tensor.shape, -noiseLevel, noiseLevel);
        return tensor.add(noise).clipByValue(0, 1);
      });
    }
    function jitterCoords(coords, maxShift = 1) {
      return coords.map(([x, y]) => [
        x + Math.floor(Math.random() * (2 * maxShift + 1)) - maxShift,
        y + Math.floor(Math.random() * (2 * maxShift + 1)) - maxShift,
      ]);
    }
    function pixelShift(inputTensor) {
      const padded = inputTensor.pad(
        [
          [1, 1],
          [1, 1],
        ],
        1
      ); // 14x14
      const cutSize = inputTensor.shape; // [12,12]
      const mutations = [];

      for (let h = 0; h < 3; h++) {
        for (let w = 0; w < 3; w++) {
          mutations.push(padded.slice([h, w], cutSize));
        }
      }

      padded.dispose();
      return mutations;
    }
    async function combosLimited(arr, maxPairs = 500) {
      const start = arr.length;
      let pairs = 0;
      for (let i = 0; i < start - 1 && pairs < maxPairs; i++) {
        for (let j = i + 1; j < start && pairs < maxPairs; j++) {
          const overlay = tf.tidy(() => tf.minimum(arr[i], arr[j]));
          arr.push(overlay);
          pairs++;
        }
      }
      return arr;
    }
    async function generateDataset(samplesPerFace = 10) {
      const xs = [];
      const ys = [];

      for (let face = 1; face <= 9; face++) {
        let shiftedAll = [];
        // Genera n dados y aplica pixelShift
        for (let i = 0; i < samplesPerFace; i++) {
          const die = createDie(face); // tu función para crear dado base
          const shifted = pixelShift(die);
          shiftedAll.push(...shifted);
          die.dispose();
        }

        // Aplica combos a todas las imágenes shiftadas de esta cara
        await combosLimited(shiftedAll);

        // Añade todas (shifted + combos) al dataset con su etiqueta
        shiftedAll.forEach((t) => {
          xs.push(t.reshape([12, 12, 1]));
          ys.push(face - 1);
        });
      }

      return {
        xs: tf.stack(xs),
        ys: tf.tensor1d(ys, "int32"),
      };
    }
    generateDataset(100).then((data) => {
      console.log("Dataset shapes:", data.xs.shape, data.ys.shape);
    });
  </script>
</html>
